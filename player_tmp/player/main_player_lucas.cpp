/*
# Copyright (c) 2014-2016, NVIDIA CORPORATION. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#  * Neither the name of NVIDIA CORPORATION nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
# OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include <iostream>
#include <sstream>
#include <iomanip>
#include <memory>

#include <VX/vx.h>
#include <NVX/nvx_timer.hpp>



//#define WINDOWS

#ifdef WINDOWS

#include "NVXIO/Application.hpp"
#include "NVXIO/FrameSource.hpp"
#include "NVXIO/Render.hpp"
#include "NVXIO/SyncTimer.hpp"
#include "NVXIO/Utility.hpp"

using namespace nvxio;
#else

#include "NVX/Application.hpp"
#include "OVX/FrameSourceOVX.hpp"
#include "OVX/RenderOVX.hpp"
#include "NVX/SyncTimer.hpp"
#include "OVX/UtilityOVX.hpp"

using namespace nvxio;
using namespace ovxio;
#endif

struct EventData
{
	EventData() : alive(true), pause(false) {}

	bool alive;
	bool pause;

};

static void keyboardEventCallback(void* context, vx_char key, vx_uint32 /*x*/, vx_uint32 /*y*/)
{



	EventData* eventData = static_cast<EventData*>(context);
	switch (key)
	{
	case 27:

	{
		eventData->alive = false;
	} break;
	case 32:
	{
		eventData->pause = !eventData->pause;
	} break;
	default: break;
	}
}

//
// main - Application entry point
//

/*
-----------------------------------
Set TextViewPort Format and content
-----------------------------------
*/
std::ostringstream DefineTxtViewPort(FrameSource::Parameters config, double total_ms, double FPSLimit)
{
	std::ostringstream txt;
	txt << std::fixed << std::setprecision(1);

	txt << "Source size: " << config.frameWidth << 'x' << config.frameHeight << std::endl;
	txt << "Algorithm: " << "No Processing" << std::endl;
	txt << "Display: " << total_ms << " ms / " << 1000.0 / total_ms << " FPS" << std::endl;

	txt << std::setprecision(6);
	txt.unsetf(std::ios_base::floatfield);

	txt << "LIMITED TO " << FPSLimit << " FPS FOR DISPLAY" << std::endl;
	txt << "Space - pause/resume" << std::endl;
	txt << "Esc - close the demo";
	return txt;
}

int main(int argc, char** argv)
{
	try
	{

		nvxio::Application &app = Application::get();

		//
		// Parse command line arguments
		//
		std::string filename = "cars.mp4";
		std::string input = app.findSampleFilePath(filename);

		app.setDescription("This sample plays a video from video-file or camera");



		app.addOption('s', "source", "Input URI", OptionHandler::string(&input));
		app.init(argc, argv);


		//
		// Create OpenVX context
		//

		ContextGuard context;

		//
		// Messages generated by the OpenVX framework will be processed by stdoutLogCallback
		//

		vxRegisterLogCallback(context, &stdoutLogCallback, vx_false_e);

		//
		// Create a Frame Source
		//

		std::unique_ptr<FrameSource> source(createDefaultFrameSource(context, input));
		if (!source || !source->open())
		{
			std::cerr << "Error: Can't open source URI " << input << std::endl;
			return Application::APP_EXIT_CODE_NO_RESOURCE;
		}


		FrameSource::Parameters config = source->getConfiguration();


		//
		// Create a Render
		//

		std::unique_ptr<Render> render(createDefaultRender(
			context, "Player Sample", 2*config.frameWidth, config.frameHeight));
		if (!render)
		{
			std::cout << "Error: Cannot open default render!" << std::endl;
			return Application::APP_EXIT_CODE_NO_RENDER;
		}

		EventData eventData;

		render->setOnKeyboardEventCallback(keyboardEventCallback, &eventData);




		vx_image frame = vxCreateImage(context, config.frameWidth,
			config.frameHeight, config.format);
		NVXIO_CHECK_REFERENCE(frame);

		Render::TextBoxStyle style = { { 200, 35, 0, 255 }, { 0, 0, 0, 127 }, { 0, 0 } }; /*Text Color (RGBA) Background */


		std::unique_ptr<SyncTimer> syncTimer = createSyncTimer();
		syncTimer->arm(1. / app.getFPSLimit());

		vx_image frame_R_U8, frame_G_U8, frame_B_U8, frame_A_U8, frame_GR_U8, frame_GG_U8, frame_GB_U8, frame_GA_U8;
		frame_R_U8 = vxCreateImage(context, config.frameWidth, config.frameHeight, VX_DF_IMAGE_U8);
		frame_G_U8 = vxCreateImage(context, config.frameWidth, config.frameHeight, VX_DF_IMAGE_U8);
		frame_B_U8 = vxCreateImage(context, config.frameWidth, config.frameHeight, VX_DF_IMAGE_U8);
		frame_A_U8 = vxCreateImage(context, config.frameWidth, config.frameHeight, VX_DF_IMAGE_U8);

		frame_GR_U8 = vxCreateImage(context, config.frameWidth, config.frameHeight, VX_DF_IMAGE_U8);
		frame_GG_U8 = vxCreateImage(context, config.frameWidth, config.frameHeight, VX_DF_IMAGE_U8);
		frame_GB_U8 = vxCreateImage(context, config.frameWidth, config.frameHeight, VX_DF_IMAGE_U8);
		frame_GA_U8 = vxCreateImage(context, config.frameWidth, config.frameHeight, VX_DF_IMAGE_U8);

		vx_image dstImg = vxCreateImage(context, 2 * config.frameWidth, config.frameHeight, config.format);
		vx_rectangle_t l_rect, r_rect;
		l_rect.start_x = 0;  l_rect.start_y = 0; l_rect.end_x = config.frameWidth; l_rect.end_y = config.frameHeight;
		r_rect.start_x = config.frameWidth; r_rect.start_y = 0; r_rect.end_x = 2 * config.frameWidth; r_rect.end_y = config.frameHeight;
		vx_image orig = vxCreateImageFromROI(dstImg, &l_rect);
		vx_image neww = vxCreateImageFromROI(dstImg, &r_rect);

		std::cout << 2 * config.frameWidth - (config.frameWidth + 1);

		nvx::Timer totalTimer;
		totalTimer.tic();
		while (eventData.alive)
		{
			FrameSource::FrameStatus status = FrameSource::OK;
			if (!eventData.pause)
			{
				status = source->fetch(frame);
			}

			switch (status)
			{
			case FrameSource::OK:
			{
				double total_ms = totalTimer.toc();

				std::cout << "Display Time : " << total_ms << " ms" << std::endl << std::endl;

				syncTimer->synchronize();

				total_ms = totalTimer.toc();
				totalTimer.tic();

				vxuChannelExtract(context, frame, VX_CHANNEL_R, frame_R_U8);
				vxuChannelExtract(context, frame, VX_CHANNEL_G, frame_G_U8);
				vxuChannelExtract(context, frame, VX_CHANNEL_B, frame_B_U8);
				vxuChannelExtract(context, frame, VX_CHANNEL_A, frame_A_U8);

				NVXIO_CHECK_REFERENCE(frame_A_U8);

				nvxuCopyImage(context, frame, orig);
				vxuGaussian3x3(context, frame_R_U8, frame_GR_U8);
				vxuGaussian3x3(context, frame_G_U8, frame_GG_U8);
				vxuGaussian3x3(context, frame_B_U8, frame_GB_U8);
				vxuGaussian3x3(context, frame_A_U8, frame_GA_U8);

				vxuChannelCombine(context, frame_GR_U8, frame_GG_U8, frame_GB_U8, frame_A_U8, neww);
				

				std::ostringstream txt = DefineTxtViewPort(config, total_ms, app.getFPSLimit());
				render->putImage(dstImg);
				render->putTextViewport(txt.str(), style);

				if (!render->flush())
					eventData.alive = false;
			} break;
			case FrameSource::TIMEOUT:
			{
				// Do nothing
			} break;
			case FrameSource::CLOSED:
			{
				// Reopen
				if (!source->open())
				{
					std::cerr << "Error: Failed to reopen the source" << std::endl;
					eventData.alive = false;
				}
			} break;
			}
		}

		//
		// Release all objects
		//
		vxReleaseImage(&frame);
	}

	catch (const std::exception& e)
	{
		std::cerr << "Error: " << e.what() << std::endl;
		return Application::APP_EXIT_CODE_ERROR;
	}


	return Application::APP_EXIT_CODE_SUCCESS;
}
